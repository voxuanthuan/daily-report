import * as vscode from 'vscode';
import axios from 'axios';
import moment from 'moment';
import { apiHeaders, JIRA_API_TOKEN, JIRA_SERVER, JIRA_USERNAME, WHO_AM_I, IAM } from './config-utils';
import TempoFetcher from './tempo/fetcher';

const IS_QC = WHO_AM_I === IAM.QC;

const GUIDE_GENERATE_TOKEN = 'https://confluence.atlassian.com/cloud/api-tokens-938839638.html';

interface JiraIssue {
    id: string;
    fields: {
      summary: string;
      status: { name: string };
      [key: string]: any;
    };
  }

export async function fetchAllTasks(): Promise<{ inProgress: any[]; open: any[] }> {
    return await fetchBacklogTasks();
}

export function calculateTotalHours(tasks: any[], previousDay: string): number {
    return tasks.reduce((sum, task) => sum + calculateWorklogHours(task, previousDay), 0);
}

export async function fetchUserDisplayName(): Promise<any> {
    try {
        const response = await axios.get(`${JIRA_SERVER}/rest/api/3/myself`, { headers: apiHeaders });
        return response.data;
    } catch (error) {
        console.error('Failed to fetch user info:', error);
        return JIRA_USERNAME.split('@')[0];
    }
}

async function fetchBacklogTasks(): Promise<{ inProgress: any[]; open: any[] }> {
    const jql = `assignee = '${JIRA_USERNAME}' AND status IN ('Selected for Development', 'Open', 'In Progress')`;
    const url = `${JIRA_SERVER}/rest/api/3/search?jql=${encodeURIComponent(jql)}&fields=summary,subtasks,status,worklog,priority,issuetype${IS_QC ? ',parent' : ''}`;

    try {
        const response = await axios.get(url, { headers: apiHeaders });
        const issues = response.data.issues || [];

        const tasksWithoutMeaningfulSubtasks = issues.filter((task: any) => {
            const subtasks = (task.fields.subtasks || []).filter((subtask: any) => subtask.fields.summary !== 'Test execution');
            return subtasks.length === 0;
        });

        return {
            inProgress: tasksWithoutMeaningfulSubtasks.filter((task: any) => task.fields.status.name === 'In Progress'),
            open: tasksWithoutMeaningfulSubtasks.filter((task: any) => task.fields.status.name === 'Open' || task.fields.status.name === 'Selected for Development'),
        };
    } catch (error: any) {
        console.error(`Failed to fetch backlog tasks: ${error.message}`, error.response?.data);
        return { inProgress: [], open: [] };
    }
}

function calculateWorklogHours(task: any, date: string): number {
    const worklogs = task.fields.worklog?.worklogs || [];
    const totalSeconds = worklogs
        .filter((log: any) => {
            return moment(log.created).format('YYYY-MM-DD') === date && log.author?.emailAddress === JIRA_USERNAME;
        })
        .reduce((sum: number, log: any) => sum + (log.timeSpentSeconds || 0), 0);
    return Math.round(totalSeconds / 3600);
}


async function fetchJiraIssueDetails(issueKey: string): Promise<JiraIssue | null> {
    if (!JIRA_SERVER) {
      vscode.window.showErrorMessage('Missing JIRA_SERVER Config');
    }
    if (!JIRA_USERNAME) {
      vscode.window.showErrorMessage('Missing JIRA_USERNAME (email) Config');
    }
    if (!JIRA_API_TOKEN) {
      const errorMessage = `Jira API token is missing. Please configure Jira Tempo API token in settings. See ${GUIDE_GENERATE_TOKEN} for more info.`;
      vscode.window.showErrorMessage(errorMessage);
    }
    const url = `${JIRA_SERVER}/rest/api/3/issue/${issueKey}?fields=summary,status,issueType,priority${WHO_AM_I === IAM.QC ? ',parent' : ''}`;
    try {
      const response = await axios.get(url, { headers: apiHeaders });
      return response.data;
    } catch (error: any) {
      console.error(`Failed to fetch Jira issue ${issueKey}: ${error?.message}`);
      return null;
    }
  }
  
  // Fetch yesterday's tasks with full issue details, with 5-day lookback
  export async function fetchPreviousWorkdayTasks(workerId: string): Promise<any[]> {
    const tempoFetcher = new TempoFetcher(workerId);
    const maxLookbackDays = 5;
    
    let currentDay = moment.tz('Australia/Sydney').subtract(1, 'day');
    
    // Skip weekends for the initial day
    while (currentDay.isoWeekday() > 5) {
      currentDay.subtract(1, 'day');
    }
  
    for (let i = 0; i < maxLookbackDays; i++) {
      // Skip weekends
      while (currentDay.isoWeekday() > 5) {
        currentDay.subtract(1, 'day');
      }
      
      const currentDateStr = currentDay.format('YYYY-MM-DD');
      
      try {
        const worklogs = await tempoFetcher.fetchWorklogs(currentDateStr, currentDateStr);
        console.log(`Fetched ${worklogs.length} worklogs for ${currentDateStr} (attempt ${i + 1}/${maxLookbackDays})`);
    
        const filteredWorklogs = worklogs.filter(worklog =>
          moment.tz(worklog.startDate, 'Australia/Sydney').format('YYYY-MM-DD') === currentDateStr
        );
    
        if (filteredWorklogs.length > 0) {
          // Fetch Jira issue details for each worklog
          const issueDetailsPromises = filteredWorklogs.map(worklog =>
            fetchJiraIssueDetails(worklog.issue.id)
          );
          const issueDetails = (await Promise.all(issueDetailsPromises)).filter((issue): issue is JiraIssue => issue !== null);
          
          console.log(`Found ${issueDetails.length} tasks for ${currentDateStr}`);
          return issueDetails;
        }
      } catch (error: any) {
        console.error(`Failed to fetch worklogs for ${currentDateStr}: ${error.message}`);
      }
      
      // Move to previous workday
      currentDay.subtract(1, 'day');
    }
    
    console.log(`No worklogs found in the last ${maxLookbackDays} workdays`);
    return [];
  }
